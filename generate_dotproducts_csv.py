##################################################
## Generates the csv files containig the dot product between compounds' embeddings and 'AML'.
##################################################

# IMPORTS:
import os, torch, sys, shutil
from pyspark.sql import functions as F
from pyspark.sql import types as T
from pyspark.context import SparkContext
from pyspark.sql.session import SparkSession
from gensim import models
from gensim.models import Word2Vec, FastText
import numpy as np
from scipy.special import softmax
import pandas as pd
from transformers import AutoTokenizer, AutoModelForMaskedLM

from target_disease import target_disease, folder_name


def clear_hugging_face_cache_folder(dirpath='/home/ac4mvvb/.cache/huggingface/hub/'):
    """ Clears the Hugging Face cache folder, to prevent memory error.

    Args:
        dirpath: the path of the folder.
    """

    for filename in os.listdir(dirpath):
        filepath = os.path.join(dirpath, filename)
        try:
            shutil.rmtree(filepath)
        except OSError:
            os.remove(filepath)


def get_token_embedding(word, embedding_matrix, method='mean'):
    """Access and returns the token embedding from the model's embedding matrix for a given word.
    Depending on the method selected, it can return different composed token embeddings.

    Args:
        word: token that the user wants to tokenize and access the token embedding;
        embedding_matrix: the model's embedding matrix, generated by model.get_input_embeddings();
        method: the selected way to compose the token embedding
            mean: compute the mean between all the subwords generated by the tokenization of the input;
            first: select the token embedding of the first subword generated by the tokenization of the input;
            last: select the token embedding of the first subword generated by the tokenization of the input.

    Returns:
        A torch tensor of 768 dimensions representing the token embedding.
    """

    vocab_ids = []
    tokenized_word = tokenizer.tokenize(word)

    for w in tokenized_word:
        vocab_ids.append(tokenizer.vocab[w])

    if method == 'mean':
        input_ids = torch.tensor(vocab_ids)
        word_token_embedding = embedding_matrix(input_ids)
        word_token_embedding = word_token_embedding.mean(0)

    elif method == 'first':
        input_ids = torch.tensor(vocab_ids[0])
        word_token_embedding = embedding_matrix(input_ids)

    elif method == 'last':
        input_ids = torch.tensor(vocab_ids[-1])
        word_token_embedding = embedding_matrix(input_ids)

    return word_token_embedding


def generate_compound_historical_record(compound):
    for method in ['first', 'last', 'mean']:
        bert_embeddings_files = sorted(
            [f.path for f in os.scandir(VALIDATION_FOLDER) if f.name.endswith('.pt') and method in f.name])

        compound_dict = {
            'year': [],
            'dot_product_result': [],
            'dot_product_result_absolute': [],
            'softmax': [],
            'normalized_dot_product_absolute': [],
            'standartized_dot_product_absolute': [],
            'softmax_normalization': [],
            'softmax_standartization': [],
        }

        for be in bert_embeddings_files:
            tensor_dict = torch.load(be)

            try:
                index_compound = tensor_dict['compound'].index(c)
                index_AML = tensor_dict['compound'].index('AML')

                AML_we = tensor_dict['word_embedding'][index_AML]
                compound_we = tensor_dict['word_embedding'][index_compound]

            except:
                continue

            dot_product = torch.dot(compound_we, AML_we).type(torch.DoubleTensor).item()
            if dot_product > 0:
                dot_product_absolute = dot_product

            else:
                dot_product_absolute = -1 * dot_product

            compound_dict['year'].append(int(be.split('.pt')[0][-4:]))
            compound_dict['dot_product_result'].append(dot_product)
            compound_dict['dot_product_result_absolute'].append(dot_product_absolute)
        print('Dot products computed')

        # Softmax:
        compound_dict['softmax'] = softmax(compound_dict['dot_product_result_absolute'])

        # Normalization:
        maximum = np.max(compound_dict['dot_product_result_absolute'])
        compound_dict['normalized_dot_product_absolute'] = [x / maximum for x in
                                                            compound_dict['dot_product_result_absolute']]
        compound_dict['softmax_normalization'] = softmax(compound_dict['normalized_dot_product_absolute'])

        # Standartization:
        # compound_dict['softmax_standartization'] = preprocessing.scale(compound_dict['dot_product_result_absolute'])
        mean = np.mean(compound_dict['dot_product_result_absolute'])
        standart_deviation = np.std(compound_dict['dot_product_result_absolute'])
        compound_dict['standartized_dot_product_absolute'] = [(x - mean) / standart_deviation for x in
                                                              compound_dict['dot_product_result_absolute']]
        compound_dict['softmax_standartization'] = softmax(compound_dict['standartized_dot_product_absolute'])

        print("Writing compound's historical record .csv file, method {}".format(method))
        pd.DataFrame.from_dict(data=compound_dict).to_csv(
            './validation/per_compound/bert/{}_{}.csv'.format(compound, method),
            columns=['year', 'dot_product_result', 'dot_product_result_absolute', 'softmax',
                     'normalized_dot_product_absolute', 'standartized_dot_product_absolute', 'softmax_normalization',
                     'softmax_standartization'], index=False)


def get_w2v_output_embedding(word, model, method):
    """ Returns the output embedding of a given word from Word2Vec or FastText model.

    Args:
        word: the token in model's vocabulary that you want the output embedding;
        meodel: Word2Vec or FastText model object;
        method: how to access the output embedding:
            'da': direct access to the token (i.e., model.wv[word]) if it exists in the vocabulary;
            'avg': compute the average of all words in vocabulary that contains word as a substring.
    """

    if method == 'da':
        index_of_word_in_vocab = 0

        try:
            index_of_word_in_vocab = list(model.wv.vocab).index(word)
        except:
            words = [x for x in list(model.wv.vocab) if word in x]
            if len(words) > 0:
                index_of_word_in_vocab = list(model.wv.vocab).index(words[0])

        return model.wv.vectors[index_of_word_in_vocab]

    elif method == 'avg':
        tokens_contaning_the_word = [x for x in list(model.wv.vocab) if word in x]

        if len(tokens_contaning_the_word) == 1:
            return model.wv.vectors[list(model.wv.vocab).index(tokens_contaning_the_word[0])]

        else:
            indexes_of_tokens_contaning_the_word = []
            for w in tokens_contaning_the_word:
                indexes_of_tokens_contaning_the_word.append(list(model.wv.vocab).index(w))

            print(len(tokens_contaning_the_word))
            print(len(indexes_of_tokens_contaning_the_word))

            output_embeddings = []
            for idx in indexes_of_tokens_contaning_the_word:
                output_embeddings.append(model.wv.vectors[idx])

            print(len(output_embeddings))
            print(type(output_embeddings[0]))
            return np.mean(
                np.stack([output_embeddings]).reshape((len(output_embeddings), output_embeddings[0].shape[0])), axis=0)


def get_compounds():
    all_chemical_from_ner = pd.read_csv(f'./data/{folder_name}/ner_table.csv')
    return all_chemical_from_ner['token'].tolist()

# MAIN PROGRAM:
if __name__ == '__main__':
    print('Starting')

    all_compounds_from_ner = get_compounds()

    # CONSTANTS:
    VALIDATION_TYPE = 'w2v'  # possible values must be: 'bert', 'w2v', or 'ft'
    W2V_MODELS_COMB15_PATH = f'./data/{folder_name}/w2v/models_yoy_combination15/'
    FT_MODELS_COMB16_PATH = f'./data/{folder_name}/fasttext/models_yoy_combination16/'

    dictionary_for_all_compounds = {}

    # if the validation is for Word2Vec models, somen constants must pointer to specific Word2Vec files:
    if VALIDATION_TYPE == 'w2v':
        MODELS_COMB15 = sorted([f.path for f in os.scandir(W2V_MODELS_COMB15_PATH) if f.name.endswith('.model')])
        os.makedirs(f'./data/{folder_name}/validation/per_compound/w2v/', exist_ok=True)

        for c in all_compounds_from_ner:
            dictionary_for_all_compounds.update({
                '{}_comb15'.format(c): {
                    'year': [],
                    'dot_product_result': [],
                    'dot_product_result_absolute': [],
                    'softmax': [],
                    'normalized_dot_product_absolute': [],
                    'standartized_dot_product_absolute': [],
                    'softmax_normalization': [],
                    'softmax_standartization': [],
                }
            }
            )

    # if the validation is for FastText models, somen constants must pointer to specific FastText files:
    elif VALIDATION_TYPE == 'ft':
        MODELS_COMB16 = sorted([f.path for f in os.scandir(FT_MODELS_COMB16_PATH) if f.name.endswith('.model')])
        os.makedirs(f'./data/{folder_name}/validation/per_compound/ft/', exist_ok=True)

        for c in all_compounds_from_ner:
            dictionary_for_all_compounds.update({
                '{}_comb16'.format(c): {
                    'year': [],
                    'dot_product_result': [],
                    'dot_product_result_absolute': [],
                    'softmax': [],
                    'normalized_dot_product_absolute': [],
                    'standartized_dot_product_absolute': [],
                    'softmax_normalization': [],
                    'softmax_standartization': [],
                }
            }
            )

    # list of years which models were trained (the length of this list is the number of models trained):
    years = sorted([int(x) for x in range(1921, 2025)])

    ########################
    # DEBUGGING:
    print('VALIDATION_TYPE: ', VALIDATION_TYPE)
    print('Years: {} to {}'.format(years[0], years[-1]))
    ########################

    # Step 1: access the token embedding of each compound after it appears for the first time in the corpus and save it into a .pt file
    for index_y, y in enumerate(years):
        print('\nCurrent year of analysis: {}'.format(y))

        if y < 1963:
            print(
                "There are no papers published until {} that contains the word 'AML', mandatory for the validation process".format(
                    y))
            continue

        print("There are at least one paper published until {} that cotains the word 'AML'".format(y))

        compounds_present_in_the_papers = []
        for key, value in FIRST_OCCURRENCE_OF_EACH_COMPOUND.items():
            if y >= value:
                compounds_present_in_the_papers.append(key)

        # step (3):
        if len(compounds_present_in_the_papers) <= 0:
            print('There are no papers published until {} that contains any of the target compounds'.format(y))
            continue

        print('There are at least one paper published until {} that contains any of the target compounds'.format(y))
        print('The compounds present in the selected papers are:')
        print(compounds_present_in_the_papers)

        if VALIDATION_TYPE == 'w2v':
            # loading Word2Vec model from file:
            print('Loading Word2Vec model')
            model_comb15 = Word2Vec.load([x for x in MODELS_COMB15 if str(y) in x][0])

            # accessing the word embedding of AML:
            try:
                AML_we_comb15 = model_comb15.wv['aml']
                print("Acessing the word embedding of 'AML'")

            except:
                print('AML is not in the vocabulary')
                continue

            # acessing the output embedding of each of the compounds present in the papers published until year y:
            for compound in compounds_present_in_the_papers:
                # METHOD 1: Direct Access to the token in the model's vocab
                print('Acessing the output embedding of {}'.format(compound))
                compound_we_comb15 = get_w2v_output_embedding(compound, model_comb15, method='da')

                dot_product_comb15 = np.dot(compound_we_comb15, AML_we_comb15).item()

                dictionary_for_all_compounds['{}_comb15'.format(compound)]['year'].append(y)
                dictionary_for_all_compounds['{}_comb15'.format(compound)]['dot_product_result'].append(
                    dot_product_comb15)
                dictionary_for_all_compounds['{}_comb15'.format(compound)][
                    'dot_product_result_absolute'].append(abs(dot_product_comb15))

        elif VALIDATION_TYPE == 'ft':
            # loading FastText model from file:
            print('Loading FastText model')
            model_comb16 = FastText.load([x for x in MODELS_COMB16 if str(y) in x][0])

            # accessing the word embedding of AML:
            try:
                AML_we_comb16 = model_comb16.wv['aml']
                print("Acessing the word embedding of 'AML'")

            except:
                print('AML is not in the vocabulary')
                continue

            # acessing the output embedding of each of the compounds present in the papers published until year y:
            for compound in compounds_present_in_the_papers:
                print('Acessing the output embedding of {}'.format(compound))
                compound_we_comb16 = get_w2v_output_embedding(compound, model_comb16, method='da')

                dot_product_comb16 = np.dot(compound_we_comb16, AML_we_comb16).item()

                dictionary_for_all_compounds['{}_comb16'.format(compound)]['year'].append(y)
                dictionary_for_all_compounds['{}_comb16'.format(compound)]['dot_product_result'].append(
                    dot_product_comb16)
                dictionary_for_all_compounds['{}_comb16'.format(compound)][
                    'dot_product_result_absolute'].append(abs(dot_product_comb16))




    if VALIDATION_TYPE == 'w2v':
        print('Generating historical record for each compound')
        for c in all_compounds_from_ner:
            for comb in ['comb15']:
                key = '{}_{}'.format(c, comb)

                # Softmax:
                dictionary_for_all_compounds[key]['softmax'] = softmax(
                    dictionary_for_all_compounds[key]['dot_product_result_absolute'])

                # Normalization:
                maximum = np.max(dictionary_for_all_compounds[key]['dot_product_result_absolute'])
                dictionary_for_all_compounds[key]['normalized_dot_product_absolute'] = [x / maximum for x in
                                                                                        dictionary_for_all_compounds[
                                                                                            key][
                                                                                            'dot_product_result_absolute']]
                dictionary_for_all_compounds[key]['softmax_normalization'] = softmax(
                    dictionary_for_all_compounds[key]['normalized_dot_product_absolute'])

                # Standartization:
                mean = np.mean(dictionary_for_all_compounds[key]['dot_product_result_absolute'])
                standart_deviation = np.std(dictionary_for_all_compounds[key]['dot_product_result_absolute'])
                dictionary_for_all_compounds[key]['standartized_dot_product_absolute'] = [
                    (x - mean) / standart_deviation for x in
                    dictionary_for_all_compounds[key]['dot_product_result_absolute']]
                dictionary_for_all_compounds[key]['softmax_standartization'] = softmax(
                    dictionary_for_all_compounds[key]['standartized_dot_product_absolute'])

                print('Writing file {}.csv'.format(key))
                pd.DataFrame.from_dict(data=dictionary_for_all_compounds[key]).to_csv(
                    './validation/per_compound/w2v/{}.csv'.format(key),
                    columns=['year', 'dot_product_result', 'dot_product_result_absolute', 'softmax',
                             'normalized_dot_product_absolute', 'standartized_dot_product_absolute',
                             'softmax_normalization', 'softmax_standartization'], index=False)

    elif VALIDATION_TYPE == 'ft':
        print('Generating historical record for each compound')
        for c in all_compounds_from_ner:
            key = '{}_comb16'.format(c)

            # Softmax:
            dictionary_for_all_compounds[key]['softmax'] = softmax(
                dictionary_for_all_compounds[key]['dot_product_result_absolute'])

            # Normalization:
            maximum = np.max(dictionary_for_all_compounds[key]['dot_product_result_absolute'])
            dictionary_for_all_compounds[key]['normalized_dot_product_absolute'] = [x / maximum for x in
                                                                                    dictionary_for_all_compounds[key][
                                                                                        'dot_product_result_absolute']]
            dictionary_for_all_compounds[key]['softmax_normalization'] = softmax(
                dictionary_for_all_compounds[key]['normalized_dot_product_absolute'])

            # Standartization:
            mean = np.mean(dictionary_for_all_compounds[key]['dot_product_result_absolute'])
            standart_deviation = np.std(dictionary_for_all_compounds[key]['dot_product_result_absolute'])
            dictionary_for_all_compounds[key]['standartized_dot_product_absolute'] = [(x - mean) / standart_deviation
                                                                                      for x in
                                                                                      dictionary_for_all_compounds[key][
                                                                                          'dot_product_result_absolute']]
            dictionary_for_all_compounds[key]['softmax_standartization'] = softmax(
                dictionary_for_all_compounds[key]['standartized_dot_product_absolute'])

            print('Writing file {}.csv'.format(key))
            pd.DataFrame.from_dict(data=dictionary_for_all_compounds[key]).to_csv(
                './validation/per_compound/ft/{}.csv'.format(key),
                columns=['year', 'dot_product_result', 'dot_product_result_absolute', 'softmax',
                         'normalized_dot_product_absolute', 'standartized_dot_product_absolute',
                         'softmax_normalization', 'softmax_standartization'], index=False)

    print('END!')