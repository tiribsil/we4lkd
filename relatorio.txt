Primeiro, juntei todos os pedaços do projeto do Matheus no notebook lma.ipynb.

Nesse processo, tirei dúvidas com o próprio Matheus e consegui entender todo o código.
Depois, parti para a adaptação do algoritmo para o meu problema.

A primeira coisa que percebi que tinha que mudar eram os termos de busca.

No código do Matheus, os termos de busca tinham sido escolhidos manualmente por um especialista, e eles incluíam sinônimos para a LMA e seus tratamentos conhecidos.

Como no meu caso a doença é dinâmica, os tratamentos devem ser buscados em tempo real de forma automática. Minhas primeiras ideias foram encontrar um site que tivesse os tratamentos conhecidos para a doença ou usar uma LLM para encontrar esses compostos.

Minha primeira ideia foi usar o PubChem para buscar os tratamentos conhecidos para a doença, mas percebi que o PubChem não tinha informações sobre os tratamentos conhecidos para a doença.

Tentei também buscar no PubMed, mas não consegui encontrar os tratamentos conhecidos para a doença.

Depois, tentei usar o DrugBank, mas me responderam que não atendiam ao Brasil.

Então, encontrei o site Medscape, que contém tratamentos para doenças.

Depois de muita luta, consegui obter os resultados de uma busca no Medscape, agora tenho que tentar extrair os compostos dessas páginas.

Acho que vou usar uma LLM mesmo pra extrair os compostos da página

Tentei usar PubMedBERT pra extrair os compostos do Medscape, mas não é muito bom e o Medscape não tem tantas páginas de protocolo de tratamento, vou tentar usar só LLM.

Usei Gemini pra fazer a query e deu certo parece, se der problema eu descubro depois.

Baixar abstracts foi bem.

Agregação dos arquivos foi bem.

Voltei no crawler para conferir a sintaxe da query.

Para o pré-processamento, comecei procurando por uma forma de normalizar os sinônimos da doença, trocando por um nome canônico.

Tive vários problemas com achar os sinônimos da doença, mas acabei conseguindo usar Entrez, só preciso do nome da doença bem certinho.

Agora preciso conseguir as tabelas de sinônimos e nomes canônicos de compostos.

Peguei as tabelas do PubChem. Vou alterar o código para ler TSV em vez de CSV, já que o PubChem fornece os dados em TSV.

Achei melhor trocar a tabela NER pronta por uma feita com base nos abstracts baixados.

Treinamento dos modelos funcionou bem.

Para Data Augmentation, vou tentar usar modelos de linguagem sequenciais com base nas embeddings e em compostos candidatos.

Então tenho que começar a analise antes pra conseguir os compostos candidatos.

A análise consistiu em tirar tudo que dependia dos tratamentos conhecidos. Agora, é usado o NER para calcular a relação de cada composto mencionado no corpus com a doença alvo ao decorrer dos anos.

Agora, para a XAI, vou pegar janelas de contexto que contém cada composto selecionado e a doença alvo, depois vou mostrar essas frases para um transformer e pedir para ele explicar a relação entre o composto e a doença.

XAI aparentemente foi muito bem. Agora preciso fazer uma saída para cada ano e comparar com as saídas com data augmentation.

Na verdade, antes disso estou tentando tirar o ruído que vem do generate_dotproducts. Trocando NER por tabela Titles da PubChem.

Filtragem de ruído foi bem, mas vou atrasar o data augmentation mais um pouco e fazer um programa principal.

Fiz o programa principal, mas os resultados não estão bons (recomendações depois das descobertas), pois os compostos só começam a ser mencionados depois do tratamento ser consolidado. Preciso rodar a pipeline duas vezes, uma pra pegar os compostos tratamento e outra adicionando esses compostos nas palavras a serem procuradas pelo crawler.

Fiz um script para ranquear as recomendações com base no número de notificações e há quanto tempo foi mencionada pela primeira vez. vou tentar usar isso para filtrar os compostos que não são relevantes.

Nova ideia: Implementar um "Fator de Especificidade Terapêutica" (O mais poderoso)

# A Lógica: Drogas de suporte (antibióticos, antifúngicos, anti-hipertensivos) são mencionadas 
# na literatura de uma vasta gama de doenças. Em contraste, um tratamento direto é, em geral, 
# discutido em um conjunto muito mais restrito de doenças. Amphotericin B aparece em artigos 
# sobre câncer, transplantes, HIV, etc. Midostaurin aparece quase que exclusivamente em artigos # sobre LMA e mastocitose sistêmica.

# Podemos quantificar essa especificidade. A ideia é análoga ao TF-IDF em processamento de 
# texto: uma palavra que aparece em todos os documentos (uma "stopword") é menos importante. Uma 
# droga que aparece em todos os "corpus de doenças" é, provavelmente, uma terapia de suporte.

# Como Implementar:

# Isto requer um pré-processamento único, mas o resultado é um "super-filtro" que beneficiará 
# todas as suas análises futuras.

#     Crie Corpos para Múltiplas Doenças: Execute sua pipeline de coleta de abstracts para um 
# conjunto diversificado de ~20-30 doenças (ex: Diabetes Tipo 2, Artrite Reumatoide, Alzheimer, 
# Asma, Hipertensão, Depressão, além das de câncer).

#     Gere a Lista de Compostos por Doença: Para cada doença, gere a lista final de compostos 
# encontrados em seu corpus (assim como você já faz).

#     Calcule o "Document Frequency" da Droga: Crie um mapa global de contagem. Para cada 
# composto no seu "universo PubChem", conte em quantos corpos de doenças diferentes ele apareceu.

#         amphotericinb: aparece em 18 de 20 doenças.

#         verapamil: aparece em 15 de 20 doenças.

#         azacitidine: aparece em 2 de 20 doenças.

#     Calcule o Fator de Especificidade (TSF - Therapeutic Specificity Factor):

#         N = Número total de doenças no seu universo (ex: 20)

#         d_c = Número de doenças em que o composto c aparece.

#         TSF(c) = log(N / d_c)

#         Este fator será alto para drogas específicas e muito baixo (próximo de zero) para drogas genéricas/de suporte.

#     Integre ao seu Score Final:

#         New_Score = Original_Score * TSF

#         Drogas como amphotericinb e verapamil terão seus scores drasticamente reduzidos, 
# enquanto azacitidine e midostaurin manterão ou aumentarão seu valor relativo.

# Vantagens: Abordagem baseada em dados, completamente agnóstica à doença, e a forma mais 
# robusta de resolver o problema de "suporte vs. direto".

Não fiz ideia ainda, estou tentando pegar a lista gerada pelo get_best_treatment_compounds e adicionar nos tópicos de interesse. Esse tópicos de interesse é um arquivo novo que usei pra substituir o uso do gemini no crawler, agora ele gera uma query bem genérica e simples pra cada linha nesse arquivo. Inicialmente, o arquivo é apenas a doença alvo, mas o código roda até a etapa 7, gera essa lista de interesse, adiciona no arquivo, e roda do zero. A ideia é incluir artigos sobre compostos relacionados a doença. Nem todos são tratamentos, mas pelo menos é alguma coisa.

Não deu muito certo, só idarubicin foi bom, primeira notificação em 1979. Vou tentar manualmente colocar tópicos de interesse agora (isso acabou sendo pegar só os top 3 da lista de get_best_treatment_compounds).

Também não deu muito certo, resultados parecidos.

Ideia da Luiza! Fazer os modelos serem incrementais, com a saída de um alimentando o crawler do próximo. Simula evolução do conhecimento.
